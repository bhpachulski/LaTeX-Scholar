\documentclass{cartilha}

\author{Instituto de Ciências Matemáticas e de Computação - USP (ICMC-USP) \\
	Universidade Federal do Mato Grosso do Sul (UFMS) \\
	Async Serviços de Informática Ltda. (ASYNC)} 

% Departamento de Computação e Estatística

\doctype{Cartilha}

\title{Como adotar Processo e Ferramentas de Software Livre no Desenvolvimento de Software}
\subtitle{Relatório técnico}

\project{Projeto SAFE (\textit{Software Engineering Available For Everyone})}
\alternativeproject{Engenharia de Software Disponível a Todos}

\sponsor{FINEP}
\date{Outubro de 2006}


\begin{document}

\frontmatter

\maketitle

\tableofcontents

\mainmatter

\chapter{Introdução}

O processo de desenvolvimento de software livre tem recebido constante atenção da comunidade,
científica e empresarial, devido, principalmente, à alta qualidade dos produtos e o baixo custo de
projetos de software livre.

O Projeto SAFE estuda o processo de software livre, com o objetivo de gerar um arcabouço para o
desenvolvimento de software, seja este aberto ou fechado, utilizando os fundamentos do processo de
software livre e integrando as ferramentas livres disponíveis.

Esta cartilha descreve como o arcabouço gerado pelo Projeto SAFE pode ser utilizado em uma empresa.
O público alvo desta cartilha são pequenas empresas de desenvolvimento de software, que podem estar 
sem um processo de desenvolvimento definido ou que queiram melhorar seu processo, a partir das
práticas comumente adotadas em processos de software livre.

Este documento estrutura-se da seguinte forma. O capítulo \ref{chapter:processo} descreve o
processo de software livre, adaptado para o ambiente da indústria de software. Esta descrição
não se restringe à produção de software aberto, abordando, conforme necessário, questões
particulares à produção de software fechado.

Os capítulos \ref{chapter:documentacao}, \ref{chapter:controleversao} e
\ref{chapter:controlealteracao} documentam as principais práticas do processo de software livre:
documentação, controle de versão e controle de alteração, respectivamente.

O capítulo \ref{chapter:exemplo} demonstra como seria a utilização do processo de software livre em
uma empresa. Esse exemplo utiliza todas as práticas anteriormente descritas (capítulos 
\ref{chapter:documentacao}, \ref{chapter:controleversao} e \ref{chapter:controlealteracao})
conforme o processo definido no capítulo \ref{chapter:processo}.

As considerações finais, capítulo \ref{chapter:conclusoes}, encerra a cartilha com informações
relevantes para a continuidade da adoção e evolução do processo de software livre.

A leitura desta cartilha deve ser acompanhada do documento ``Modelo para Desenvolvimento de Projetos
de Software Livre -- Fundamentos Conceituais'', também definido pelo Projeto SAFE. Ele define
conceitos chaves do processo do software livre. Esta cartilha segue as definições nele contidas.



\chapter{Processo de software livre}
\label{chapter:processo}


Todo processo de software exige adaptações para sua bem sucedida implantação no ambiente da
empresa. As variáveis do processo devem ser compreendidas e documentadas, facilitando futuras
implantações. A comunidade científica ainda não alcançou esse patamar de conhecimento sobre o
processo de software livre. Além disso, os estudos disponíveis são sobre processos de software livre
para a produção de software livre. Esta cartilha trata de processos de software livre para a
produção de qualquer tipo de software, seja livre ou fechado. Em outras palavras, não é possível
pressupor o mesmo grau de transparência encontrada nos projetos de software livre para os projetos
de software comercial.

% Os estudos apontam que a comunidade exerce um papel importante, se não vital, no processo
% de software livre. Por isso, projetos de software fechado que desconsiderem a comunidade
% podem não funcionar conforme o esperado caso utilizem o processo de software livre.

Uma característica do processo de software livre é que ele possui vários níveis, determinados pelo
envolvimento da comunidade  \cite{reis:2003}. Essa comunidade é composta por desenvolvedores (da
própria empresa ou de terceiros) e usuários (clientes). Conforme o tamanho e a complexidade dessa
comunidade, temos os seguintes níveis do ciclo de vida de um processo de software livre:

\begin{enumerate}
	\item Criação.
	\begin{itemize}
		\item Criado por uma única pessoa.
		\item Motivado por fatores pessoais.
		\item Criado com a intenção prévia de licenciar o software através de uma licença
de software livre.
	\end{itemize}

	\item Lançamento público.
	\begin{itemize}
		\item Software anunciado publicamente.
		\item Disponibilização do software.
	\end{itemize}

	\item Crescimento e organização.
	\begin{itemize}
		\item Estímulo e apoio à comunidade de usuários.
		\item Estabelecimento de meios de comunicação para a comunidade de software livre
(listas de discussão por correio eletrônico).
		\item Atribuição de responsabilidades à comunidade (grupos de desenvolvedores
principais, desenvolvedores externo e usuários).
		\item Desenvolvimento concorrente.
		\item Emprego de processo de controle de versão.
		\item Uso de ferramentas de controle de versão.
	\end{itemize}

	\item Maturidade.
	\begin{itemize}
		\item Emprego de processo de controle de alteração.
		\item Uso de ferramentas de controle de alteração.
		\item Emprego de processo de controle de lançamento.
		\item Desenvolvimento de ferramentas próprias para o desenvolvimento de software.
	\end{itemize}
\end{enumerate}

A cada nível, a comunidade ao redor do software cresce e torna-se mais complexa. Os processos
adotadas a cada incremento não são, necessariamente, oriundos do ensejo de melhorar a qualidade
das atividades e seus subprodutos por si, mas melhorar a coordenação e efetividade da pessoas
envolvidas no desenvolvimento.

Esses níveis foram determinados pela observação de projetos de software livre, mas é possível
interpretá-los para projetos de software fechado desenvolvidos em uma empresa:

\begin{description}
	\item Criação
	\begin{itemize}
		\item Criado por uma única pessoa.
		\item Motivado por fatores de mercado e metas da empresa.
		\item Criado com a intenção prévia de licenciar o software através de uma licença
de software fechado.
	\end{itemize}

	\item Lançamento público
	\begin{itemize}
		\item Software anunciado publicamente e para potenciais clientes.
		\item Disponibilização de versões de demonstração ou limitadas do software.
	\end{itemize}

	\item Crescimento e organização.
	\begin{itemize}
		\item Estímulo e apoio, ainda que limitados, à comunidade de usuários.
		\item Estabelecimento de meios de comunicação para a comunidade (listas de discussão
por correio eletrônico).
		\item Atribuição de responsabilidades à comunidade (grupos de desenvolvedores
principais e desenvolvedores externo).
		\item Desenvolvimento concorrente.
		\item Emprego de processo de controle de versão.
		\item Uso de ferramentas de controle de versão.
	\end{itemize}

	\item Maturidade
	\begin{itemize}
		\item Emprego de processo de controle de alteração.
		\item Uso de ferramentas de controle de alteração.
		\item Emprego de processo de controle de lançamento.
		\item Desenvolvimento ou compra de ferramentas para o desenvolvimento de software.
	\end{itemize}
\end{description}

Apesar de existirem relevantes diferenças entre o emprego do processo de software livre em projetos
de software fechado, principalmente na fase ``Crescimento e Organização'', existe a
correspondência entre os processos. De fato, tanto software livre quanto fechado são softwares
comerciais, estão essa comunidade era esperada.

O primeiro passo para a implantação do processo de software livre é identificar a qual nível de
processo a empresa se encontra ou é capaz de alcançar no momento. Para os primeiros níveis,
``Criação'' e ``Lançamento público'', não existem muitos requisitos para uma empresa e,
provavelmente, elas se qualificam para tanto. Esta cartilha concentra-se, portanto, em três
pontos-chave do processo de software livre:

\begin{description}
	\item[Documentação] Atividade desempenhada durante todo o processo, independente do nível
de maturidade. A partir da documentação interna e de desenvolvimento, em ``Criação'', até ao
oferecimento e obtenção de informações diretamente dos clientes (sistemas de ajuda --
\foreign{helpdesk} --, listas de discussão, controle de disponibilização de novas versões do
software, etc).
	\item[Controle de versão] Atividade desempenhada a partir de ``Crescimento e organização''.
Consiste no controle da evolução do software, armazenando-se todas as alterações realizadas nos
arquivos de código-fonte e demais artefatos de software.
	\item[Controle de alteração] Atividade desempenhada a partir de ``Maturidade''. Consiste no
controle das alterações realizadas no software, armazenando-se as razões para as modificações nos
arquivos de código-fonte e demais artefatos de software, complementando assim o controle de versão.
\end{description}




\section{Preparação para iniciar uma atividade}
\label{sec:preparacao}


\begin{itemize}
\item Diferenciar Processo de Software Livre do Processo de Software Convencional 
\item Esclarecer o objetivo desta cartilha:  auxiliar os desenvolvedores oriundos de diversas 
organizações, a adotarem o processo de software livre, utilizando ferramentas, procedimentos e
técnicas comumente adotadas com sucesso por desenvolvedores de projetos de software livre. 
Assim, está fora do escopo desse objetivo a política e licenças que serão adotadas por esses
desenvolvedores, em suas organizações, para com o produto de software a ser contruído.
\end{itemize}





\section{O Processo de Software Livre }
\label{sec:processo}

A seguir são apresentados aspectos gerais do processo de software em projetos de software livre.

\section{Obtenção de Requisitos}

A forma como os requisitos são capturados depende da ``idade'' e do
tamanho do projeto. Na forma mais simples, o desenvolvedor do projeto e o usuário
são a mesma pessoa. Neste caso, é comum a ausência total de um
processo convencional de requisitos. 

% E na forma mais complicada, como é que é? Na verdade, uma característica essencial em projetos de
% software livre é o usuário-desenvolvedor. Claro, em uma empresa isso não será o caso, ou será?
% Que empresa produzirá algo do qual ela não é cliente ou tem conhecimento do domínio da aplicação?
% Se o funcionário não se identifica com a missão da empresa, será que ele está no lugar correto?
%
% O que seria um processo convencional de requisitos? E um não convencional? Os requisitos são
% capturados dos interessados. O problema é que eles não são formalizados, ou melhor, são
% formalizados diretamente como implementação. Entre a ``obtenção do requisito'' e a sua
% apresentação pública, ele permanece apenas na cabeça do desenvolvedor.
%
% Ao mesmo tempo, os ciclos tipicamente curtos de desenvolvimento fazem com que a apresentação
% pública desses requisitos, mesmo que no formato de código (formal) gerem discussões típicas
% dos processos ``tradicionais'' de engenharia de requisitos. Esse código pode evoluir para algo
% passível de inclusão oficial no código do projeto ou ser totalmente refeito, jogado fora.
% Imagine algo como prototipação. Talvez por isso que projetos de software livre gostam de utilizar
% linguagens interpretadas (scripts), como Python, Perl e PHP, ou que o desenvolvedor tenha tanto
% domínio que ela torna-se simples (C para o Kernel, C++ para o KDE, etc).

% O problema da engenharia de requisitos em software livre não é durante o projeto. O problema é o
% início. Em projetos de software livre, o início ou é nebuloso (scrach your own itch) ou é baseado
% em produtos já existentes ou padrões e especificações de mercado ou organizações. Se for para
% realmente seguir o OSSEP (Open Source Software Engineering Process), a empresa deve guiar-se por
% isso.



Em projetos em que há mais de um desenvolvedor, a captura e o
registro de requisitos são realizadas utilizando-se listas de
email. Nestes casos, há uma distinção clara entre desenvolvedores
e usuários.

Em projetos maiores, em que há muitos usuários e
desenvolvedores, os requisitos geralmente são capturados usando as
mesmas ferramentas utilizadas para gerenciamento de erros.
O mecanismo utilizado para gerenciar os requisitos é o
mesmo que é usado para correção de erros. Por exemplo, os
requisitos são classificados pela importância, dependência, etc e
os usuários podem utilizar a ferramenta para sugerir a
implementação de novos requisitos (artigo free Software Engineering).

% O artigo do Kiko sobre o Mozilla deve explicar isso, copiar de lá.


Alguns projetos replicam a funcionalidade de outro pacote de
software, de forma total ou parcial. Nestes casos, há pouca ênfase na
especificação formal de requisitos.

% E mesmo nos outros existe ênfase? Acho que não.


%Em relação à participação de usuários finais na definição dos requisitos, duas abordagens distintas
podem ser observadas. Para o desenvolvimento de alugns projetos ocorrem frequentemente encontros ou
discussões com usuários finais para definir as funcionalidades e o comportamento do sistema. Em
outra parcela de projetos as funcionalidades são determinadas internamente pelas equipes. Isso não
significa, no entanto, que os usuários não participam da definição das funcionalidades, pois eles
propõem extensões que o grupo de desenvolvimento pode aceitar ou rejeitar e são consultados em
relação a determinadas funcionalidades do sistema.

%Os usuários possuem participação ativa na implementação de requisitos, ou seja, possuem a liberdade
de implementar uma mudança desejada e submetê-la para aprovação.



\section{Implementação}

No desenvolvimento de software livre, os esforços são concentrados principalmente na fase de
implementação.
Testes de unidade geralmente são executados (informalmente) a
medida que os módulos são implementados.

% Testes de unidade em software livre não são uma prática tão comum (ao menos não parece). Existe
% algum trabalho que afere isso?


A fase de implementação de um projeto de software livre ocorre de forma distribuída e colaborativa.
O sucesso de muitos projetos de software livre deve-se à evolução da internet. 

% Eu tiraria o _muitos_. Na verdade, o que existia de software livre antes das redes e da Internet?
% Era muito difícil (caro) divulgar software (livre) sem as redes como a Internet. Talvez a Internet
% seja essencial para projetos de software livre.


Por definição, o código-fonte que o projeto produz é distribuído através de uma licença de software
livre. O código é mantido em um repositório público de onde qualquer pessoa pode copiá-lo.  
 


\section{Testes} 

Em projetos de software livre, não são comumente elaborados planos de teste formais. Não é comum o
uso de técnicas de teste difundidas e maduras em projetos de pequeno e médio porte, no entanto,
projetos maiores tendem a usar técnicas mais especializadas.  

% Quais são as técnicas de teste difundidas em questão? Se for a definição usual de testes adotada
% pela maioria das pequenas empresas, software livre adota e muito :-)

Normalmente os usuários executam testes considerando grandes
variedades de usos, arquiteturas e combinações. A paralelização de testes é comum no desenvolvimento
de software livre. Uma dificuldade enfrentada pela comunidade é a
organização eficiente do {\it feedback} dos usuários. 

% \ref? São poucos os projetos que executam testes sistematicamente, quanto mais paralelamente.
% Agora, se for no sentido que os vários usuários, durante a utilização da ferramenta, atuam como
% testadores...

De acordo com Zhao \& Elbaum, poucos projetos utilizam uma baseline de testes, o que provavelmente
indica a ausência de testes de regressão. Em grandes sistemas, aproximadamente 50\% possui suite
para testes de regressão. 

% Referência?



\section{Comunicação}

O desenvolvimento de projetos de software livre é fortemente dependente da disponibilização e
utilização de alguns recursos fundamentais que favorecem a comunicação entre os partipantes dos
projetos (líder, desenvolvedores e usuários). 

O correio eletrônico possibilita aos usuários o contato direto com o coordenador do projeto ou com
os responsáveis pela integração de código. Listas de discussão favorecem a troca de mensagens entre
usuários e desenvolvedores referentes ao uso e operação do software, decisões de projeto, etc.
Repositórios de software possibilitam que usuários e desenvolvedores tenham acesso às versões do
software. Sistemas para controle de alterações permitem que diferentes tipos de {\it bugs} sejam
registrados.    

% Coisas nem tão baixo nível também são importantes. O simples anúncio de novas versões, por
% exemplo. As páginas dos projetos, que centralizam (o acesso a) a comunicação entre usuários e
% desenvolvedores. 


\section{Controle de Configuração}







\chapter{Documentação}
\label{chapter:documentacao}




\chapter{Controle de versão}
\label{chapter:controleversao}

% Definição
% Objetivo (vantagens, oq melhora no processo)
% Quando utilizar/implementar (em quais situações)
% Descrição do processo de utilzação
% Procedimento de implantação (instalação dos softwares necessários, alocar
% pessoas/responsabilidades, treinamento, verificação/validação)


Uma das principais atividades relacionadas a controle de configuração cumpridas em desenvolvimento
de software livre é o controle de versões. A ferramenta CVS ({\it Concurrent Versions System})
\cite{CVS05} é a mais utilizada neste sentido. 

% Subversion está tomando uma parcela importante do mercado. De fato, a maioria dos grandes
% projetos migrou ou está migrando para algo diferente do CVS (geralmente Subversion, mas também
% Git e Mercurial).

Outras atividades são a gerência de compilação e o controle de alterações. Em relação à a gerência
de compilação, utiliza-se ferramentas simples, como o {\it make} e o {\it autoconf}. O controle de
alterações é particular a cada projeto mas em termos gerais difere substancialmente do processo
convencional por não utilizar pré-alocação de trabalho (ref 59 kiko - asklund).  

% Chamar o autoconf/automake de simples é um exagero. Mesmo o Make pode ser complicado (experimente
% analisar o make de projetos grandes). Seria melhor dizer que a gerência é automatizada por
% ferramentas (autoconf/automake/make), mas não afirmar que é ``simples''.






\chapter{Controle de alteração}
\label{chapter:controlealteracao}









\chapter{Exemplo de uso do processo em uma empresa}
\label{chapter:exemplo}




\chapter{Considerações finais}
\label{chapter:conclusoes}


\bibliographystyle{apalike} 
\bibliography{doc}

\end{document}


